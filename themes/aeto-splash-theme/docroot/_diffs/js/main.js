//Globals
var isTablet = false,
isPhone = false,
lineWidths = 500;


AUI().ready(
	'liferay-hudcrumbs', 'liferay-navigation-interaction', 'liferay-sign-in-modal',
	function(A) {
		var navigation = A.one('#navigation');

		if (navigation) {
			navigation.plug(Liferay.NavigationInteraction);
		}

		var siteBreadcrumbs = A.one('#breadcrumbs');

		if (siteBreadcrumbs) {
			siteBreadcrumbs.plug(A.Hudcrumbs);
		}

		var signIn = A.one('li.sign-in a');

		if (signIn && signIn.getData('redirect') !== 'true') {
			signIn.plug(Liferay.SignInModal);
		}
	}
);

// Transition In

AUI().ready(
	function(A) {
		var node = A.one("body"),
		bodyNode = node,
		win = A.one(window),
		nodes = [],
		width = bodyNode.get("winWidth"),
		height = bodyNode.get("winHeight"),
		diagonal = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)),
		containerNode = A.one('.transition-container'),
		angle = -90 + Math.atan(width / height) * (180 / Math.PI),
		nodeCt = 0,
		spaceCt = 0, //0-100% amount of screen space used
		minWidth = 2, //2
		maxWidth = 5, //5
		curWidth = 0,
		bgCss = "",
		menuItems = [A.one('.item .one'), A.one('.item .two'), A.one('.item .three'), A.one('.item .four'), A.one('.item .five')],
		topLineNode = A.one('.top-line'),
		bottomLineNode = A.one('.bottom-line'),
		nodesMaxLength = 0, //number of stripes at maximum generated by RNG
		nodesPercentAnimate = 0.01; //at what % of stripes to begin other animations

		win.on(
			['resize', 'load'],
			A.debounce(checkWidth, 100)
		);

		function checkWidth() {
			width = bodyNode.get("winWidth");
			height = bodyNode.get("winHeight");
			isTablet = (width <= 979);
			isPhone = (width <= 767);

			if (isPhone)
				A.one('.splash-menu-content').setStyle('top', 'calc(34% - -' + (40 + 130 * (width / 767)) + 'px)');
			else {
				A.one('.splash-menu-content').setStyle('top', 'calc(34% - -170px)');
			}

			if (isTablet || isPhone) {
				minWidth *= 4;
				maxWidth *= 4;
			}
		}

		win.on(
			['resize'],
			A.debounce(widthChanges, 100)
		);

		checkWidth();

		// Responsive Width
		function widthChanges() {
			if (isTablet || isPhone) {
				menuItems[0].setStyle('opacity', 1);
	        	menuItems[4].setStyle('opacity', 1);
			}
			else {
				menuItems[0].setStyle('opacity', '');
	        	menuItems[4].setStyle('opacity', '');
			}

			setLineWidths();
		}

		function setLineWidths() {
			if (isTablet) {
				topLineNode.setStyle('width', lineWidths - 100);
        		bottomLineNode.setStyle('width', lineWidths - 100);
			}
			if (isPhone) {
        		topLineNode.setStyle('width', width * .6);
        		bottomLineNode.setStyle('width', width * .6);
        	}
        	else {
        		topLineNode.setStyle('width', lineWidths);
        		bottomLineNode.setStyle('width', lineWidths);
        	}
		}

		containerNode.setStyle('-webkit-transform', "rotate(" + angle + "deg)");
		containerNode.setStyle('-moz-transform', "rotate(" + angle + "deg)");
		containerNode.setStyle('-ms-transform', "rotate(" + angle + "deg)");	
		containerNode.setStyle('-o-transform', "rotate(" + angle + "deg)");
		containerNode.setStyle('transform', "rotate(" + angle + "deg)");
		containerNode.setStyle('height', diagonal);
		containerNode.setStyle('marginBottom', width * -0.5 + "px");
		containerNode.setStyle('marginLeft', height * 0.5 + "px");		

		while (spaceCt < 100) {
			curWidth =  Math.random() * (maxWidth - minWidth) + minWidth;
			if (curWidth + spaceCt > 100) curWidth = 100 - spaceCt;
			spaceCt += curWidth;

			//console.log(spaceCt);
			nodes.push(A.Node.create("<div class='transition-stripe'></div>"));
			nodes[nodeCt].setStyle('width', diagonal * 2);
			nodes[nodeCt].setStyle('height', curWidth + "%");
			nodes[nodeCt].setStyle('marginLeft', diagonal * -1 + "px");
			//node.setStyle('margin-left', diagonal);	
			//nodes[nodeCt].setStyle('background-color', "rgb(" + Math.round(Math.random() * 255) + ", 0 , 0)");
			containerNode.append(nodes[nodeCt]);

			var randColor = Math.round(Math.random() * 360);

			if (bgCss == "") {
				bgCss = nodes[nodeCt].getStyle('backgroundImage');
				bgCss = bgCss.substr(0, bgCss.indexOf('('));
			}

			if(bgCss != "-webkit-gradient") {
				nodes[nodeCt].setStyle("backgroundImage", bgCss + "(left, hsla(" + randColor + ", 67%, 36%, 0) 0%, hsla(" + randColor + ", 35%, 75%, 1) 32%, #ffffff 54%)");
			}
			else {
				nodes[nodeCt].setStyle("backgroundImage", bgCss + "(linear, 0% 50%, 100% 50%, color-stop(0%, hsla(" + randColor + ", 67%, 36%, 0)), color-stop(32%, hsla(" + randColor + ", 35%, 75%, 1)), color-stop(54%, #ffffff)");
			}
		
			nodeCt++;
		}

		A.one('.loadpaper').remove();
		nodesMaxLength = nodes.length;

		function transitionComplete(){
			containerNode.remove();
		}

		function wipeStripe() {
			if (nodes.length > 0) {
				var idx = Math.round(Math.random() * (nodes.length - 1));

				nodes[idx].setStyle('marginLeft', diagonal * 2 + "px");
				nodes.splice(idx, 1);
			} 
			else {
				clearInterval(stripeWiper);
				setTimeout(transitionComplete, 1700);
				secondaryAnimations();
				
			}
		}

		function secondaryAnimations() {
			setTimeout(function() {
				A.one('.aeto-logo').setStyle('opacity', 1);

				setTimeout(function() {
					setLineWidths();

					topLineNode.setStyle('opacity', 1);
					bottomLineNode.setStyle('opacity', 0.8);

					setTimeout(function() {
						topLineNode.setStyle('-webkit-transition-duration', "0.45s");
						topLineNode.setStyle('-moz-transition-duration', "0.45s");
						topLineNode.setStyle('-o-transition-duration', "0.45s");
						topLineNode.setStyle('transitionDuration', "0.45s");
						bottomLineNode.setStyle('-webkit-transition-duration', "0.45s");
						bottomLineNode.setStyle('-moz-transition-duration', "0.45s");
						bottomLineNode.setStyle('-o-transition-duration', "0.45s");
						bottomLineNode.setStyle('transitionDuration', "0.45s");

						menuItems[1].setStyle('opacity', 1);
						menuItems[1].setStyle('top', 0);

						setTimeout(function() {
							menuItems[2].setStyle('opacity', 1);
							menuItems[2].setStyle('top', 0);

							setTimeout(function() {
								menuItems[3].setStyle('opacity', 1);
								menuItems[3].setStyle('top', 0);

								setTimeout(function() {
									
									menuItems[0].setStyle('left', 0);
									
									menuItems[4].setStyle('right', 0);

									if (isTablet || isPhone) {
										menuItems[0].setStyle('opacity', 1);
										menuItems[4].setStyle('opacity', 1);
									}
								}
								, 200);
							}
							, 200);
						}
						, 200);
					}
					, 850);
				}
				, 400);
			}
			, 850);

		}

		var stripeWiper = setInterval(wipeStripe, 50);

		//console.log(width + " " + height + " " + diagonal + " " + angle);
	}
);

// Hover event

AUI().use('event-hover', 'transition', function (A) {
	var topLineNode = A.one('.top-line');
	var bottomLineNode = A.one('.bottom-line');

    function over() {
    	if (!isTablet && !isPhone) {
    		topLineNode.setStyle('width', 850); //needs to be calculated
	        bottomLineNode.setStyle('width', 850);
	        
	        A.one('.left-grad').setStyle('left', -180);
	        A.one('.right-grad').setStyle('right', -180);
	        A.one('.left-grad').setStyle('opacity', .3);
	        A.one('.right-grad').setStyle('opacity', .3);

	        A.one('.menu-items .item .one').setStyle('opacity', 1);
	        A.one('.menu-items .item .five').setStyle('opacity', 1);
    	}
    }

    function out() {
    	if (!isTablet && !isPhone) {
	        topLineNode.setStyle('width', 500);
	        bottomLineNode.setStyle('width', 500);

	        A.one('.left-grad').setStyle('left', '');
	        A.one('.right-grad').setStyle('right', '');
	        A.one('.left-grad').setStyle('opacity', '');
	        A.one('.right-grad').setStyle('opacity', '');

	        A.one('.menu-items .item .one').setStyle('opacity', 0);
	        A.one('.menu-items .item .five').setStyle('opacity', 0);
	    }
    }
    // Two callbacks, `mouseenter` and `mouseleave`
   
    A.one('.splash-menu').on('hover', over, out);
});

// SFX

AUI().ready(
	function(A) {
		// ====================== Crystal Color Cycling ======================
		var idx = 0;
		var colorCycle = [
			"rgba(255, 0, 0,0.8)",
			"rgba(0, 230, 0,0.8)",
			"rgba(0, 0, 255 ,0.8)",
		];

		myTimer();
		setInterval(myTimer, 3000);

		function myTimer() {
			if(idx > colorCycle.length) idx = 0;
			A.one('.aeto-crystal ').setStyle('backgroundColor', colorCycle[idx]);
			idx++;
		}

		// ====================== Particle Generation ======================

		var maxParticles = 70,
		particleSize = 2,
		emissionRate = 0.10,
		emissionCount = 1,
		emissionPermit = 0,
		objectSize = 2,
		fadeTime = 100, // drawSize of emitter/field
		blankTime = 80, //0
		fadeIn = 100, //0
		fadeStill = 20, //200
		maxOpacity = .5, //1
		colorCt = 0,
		colorSpd = .3
		activeEmitter = 0;

		var canvas = document.querySelector('canvas');
		var ctx = canvas.getContext('2d');

		canvas.width = A.one('canvas').get('clientWidth');
		canvas.height = A.one('canvas').get('clientHeight');
		//canvas.height = window.innerHeight;

		function Particle(point, velocity, acceleration) {
			this.position = point || new Vector(0, 0);
			this.velocity = velocity || new Vector(0, 0);
			this.acceleration = acceleration || new Vector(0, 0);
			this.fadeProgress = 0;
		}

		Particle.prototype.submitToFields = function (fields) {
			// our starting acceleration this frame
			var totalAccelerationX = 0;
			var totalAccelerationY = 0;

			// for each passed field
			for (var i = 0; i < fields.length; i++) {
				var field = fields[i];

				// find the distance between the particle and the field
				var vectorX = field.position.x - this.position.x;
				var vectorY = field.position.y - this.position.y;

				// calculate the force via MAGIC and HIGH SCHOOL SCIENCE!
				var force = field.mass / Math.pow(vectorX*vectorX+vectorY*vectorY,1.5);

				// add to the total acceleration the force adjusted by distance
				totalAccelerationX += vectorX * force;
				totalAccelerationY += vectorY * force;
			}

			// update our particle's acceleration
			this.acceleration = new Vector(totalAccelerationX, totalAccelerationY);
		};

		Particle.prototype.move = function () {
			this.velocity.add(this.acceleration);
			this.position.add(this.velocity);
		};

		function Field(point, mass) {
			this.position = point;
			this.setMass(mass);
		}

		Field.prototype.setMass = function(mass) {
			this.mass = mass || 100;
			this.drawColor = mass < 0 ? "#f00" : "#0f0";
		}

		function Vector(x, y) {
			this.x = x || 0;
			this.y = y || 0;
		}

		Vector.prototype.add = function(vector) {
			this.x += vector.x;
			this.y += vector.y;
		}

		Vector.prototype.getMagnitude = function () {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		};

		Vector.prototype.getAngle = function () {
			return Math.atan2(this.y,this.x);
		};

		Vector.fromAngle = function (angle, magnitude) {
			return new Vector(magnitude * Math.cos(angle), magnitude * Math.sin(angle));
		};

		function Emitter(point, velocity, spread) {
			this.position = point; // Vector
			this.velocity = velocity; // Vector
			this.spread = spread || Math.PI / 32; // possible angles = velocity +/- spread
			this.drawColor = "#999"; // So we can tell them apart from Fields later
		}

		Emitter.prototype.emitParticle = function() {
			// Use an angle randomized over the spread so we have more of a "spray"
			var angle = this.velocity.getAngle() + this.spread - (Math.random() * this.spread * 2);

			// The magnitude of the emitter's velocity
			var magnitude = this.velocity.getMagnitude();

			// The emitter's position
			var position = new Vector(this.position.x, this.position.y);

			// New velocity based off of the calculated angle and magnitude
			var velocity = Vector.fromAngle(angle, magnitude);

			// return our new Particle!
			return new Particle(position,velocity);
		};

		function addNewParticles() {
			// if we're at our max, stop emitting.
			if (particles.length > maxParticles) return;

			// for each emitter
			//for (var i = 0; i < emitters.length; i++) {

			emissionPermit += emissionRate;
			// emit [emissionRate] particles and store them in our particles array\
			//console.log(Math.round(Math.random() * (emitters.length - 1)));
			if (emissionPermit >= 1.0) {
				for (var i = 0; i < emissionCount; i++) {
					particles.push(emitters[activeEmitter].emitParticle());

				}
				
				emissionPermit = 0;
			}

			//}
		}

		function plotParticles(boundsX, boundsY) {
			// a new array to hold particles within our bounds
			var currentParticles = [];

			for (var i = 0; i < particles.length; i++) {
				var particle = particles[i];
				var pos = particle.position;

				// If we're out of bounds, drop this particle and move on to the next
				if (pos.x < 0 || pos.x > boundsX || pos.y < 0 || pos.y > boundsY || i > maxParticles) continue;

				// Update velocities and accelerations to account for the fields
				particle.submitToFields(fields);

				// Move our particles
				particle.move();

				// Add this particle to the list of current particles
				currentParticles.push(particle);
			}

			// Update our global particles reference
			particles = currentParticles;
		}

		function drawParticles() {
			colorCt += colorSpd; 
				if (colorCt > 360) {
					colorCt = 0;
				}
			
			for (var i = 0; i < particles.length; i++) {
				if (particles[i].fadeProgress < blankTime + fadeIn + fadeStill + fadeTime) {
					particles[i].fadeProgress += 1;
				}

				

				if (particles[i].fadeProgress > blankTime) {
					if (particles[i].fadeProgress < fadeIn + blankTime) {
						ctx.fillStyle = 'hsla(' + colorCt + ', 100%, 70%, ' + (particles[i].fadeProgress - blankTime) / fadeIn * maxOpacity + ')';
					}
					else if (particles[i].fadeProgress < fadeIn + fadeStill + blankTime) {
						ctx.fillStyle = 'hsla(' + colorCt + ', 100%, 70%, ' + maxOpacity + ')';
					}
					else {
						ctx.fillStyle = 'hsla(' + colorCt + ', 100%, 70%, ' + (fadeTime - (particles[i].fadeProgress - fadeIn - fadeStill - blankTime)) / fadeTime * maxOpacity + ')';
					}

					var position = particles[i].position;

					ctx.beginPath();
					ctx.arc(position.x, position.y, particleSize, 0, Math.PI * 2);
					ctx.closePath();
					ctx.fill();
					ctx.shadowColor = 'hsla(' + colorCt + ', 100%, 75%,  1)';
				    ctx.shadowBlur = 4;
				    ctx.shadowOffsetX = 0;
				    ctx.shadowOffsetY = 0;
				}
			}
		}

		function drawCircle(object) {
			ctx.fillStyle = object.drawColor;
			ctx.beginPath();
			ctx.arc(object.position.x, object.position.y, objectSize, 0, Math.PI * 2);
			ctx.closePath();
			ctx.fill();
		}
		 
		var particles = []; 

		var midX = canvas.width / 2;
		var midY = canvas.height / 2; 

		// Add one emitter located at `{ x : 100, y : 230}` from the origin (top left)
		// that emits at a velocity of `2` shooting out from the right (angle `0`)
		var emitters = [
			//new Emitter(new Vector(midX, midY), Vector.fromAngle(-2.5, 2.5))
			new Emitter(new Vector(midX, canvas.height - 50), Vector.fromAngle(20.42, 1)),
			new Emitter(new Vector(midX + 45, canvas.height - 190), Vector.fromAngle(100, 4))
		];

		// Add one field located at `{ x : 400, y : 230}` (to the right of our emitter)
		// that repels with a force of `140`
		var fields = [
			new Field(new Vector(midX, canvas.height - 20), -8),
			new Field(new Vector(midX, 0), 0)
		];

		function loop() {
			clear();
			update();
			draw();
			queue();
		}

		function clear() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
		}

		function update() {
			addNewParticles();
			plotParticles(canvas.width, canvas.height);
		}

		function draw() {
			drawParticles();
			//fields.forEach(drawCircle);
			//emitters.forEach(drawCircle);
		}

		function queue() {
			window.requestAnimationFrame(loop);
		}

		loop();

		function getMousePos(canvas, evt) {
			var rect = canvas.getBoundingClientRect();
			return {
				x: evt.clientX - rect.left,
				y: evt.clientY - rect.top
			};
		}

		canvas.addEventListener('mousemove', function(evt) {
			var mousePos = getMousePos(canvas, evt);
			var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
			fields[1].position.x = mousePos.x ;
			fields[1].position.y = mousePos.y ;
		}, false);

		canvas.addEventListener('mouseover', function(evt) {
			fields[1].setMass(400);
		}, true);

		canvas.addEventListener('mouseout', function(evt) {
			fields[1].setMass(0);
			fields[1].position.x = canvas.width / 2;;
			fields[1].position.y = 0;
		}, true);

		var maxParticlesO = maxParticles;
		var emissionRateO = emissionRate;
		var blankTimeO = blankTime;
		var emissionCountO = emissionCount;
		var activeEmitterO = activeEmitter;

		function overItem () {
			maxParticles = 300;
			emissionRate = 1.60;
			blankTime = 0;
			emissionCount = 4;
			activeEmitter = 1;
			fields.push(new Field(new Vector(midX - 80, canvas.height - 100), 6000));
			fields.push(new Field(new Vector(midX + 20, canvas.height - 100), 1000));
			
			//array.splice(1, 1);
		}

		function offItem () {
			maxParticles = maxParticlesO;
			emissionRate = emissionRateO;
			blankTime = blankTimeO;
			emissionCount = emissionCountO;
			activeEmitter = activeEmitterO;
			fields.splice(2, 2);
		}

		A.all(".item").each(
			function(thisNode) {
				thisNode.on("hover", overItem, offItem);
			}
		);
	}
);
